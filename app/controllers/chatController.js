const openAIService = require("../services/openAIService");
const deepseekService = require("../services/deepseekService");
const chatService = require("../services/chatService");
const responseService = require("../services/responseService");

// Method that calls only ChatGPT
async function chatWithOpenAIChatGPT(req, res) {
  try {
    console.log("Body received:", req.body);
    const { chatId, userMessage } = req.body;

    if (!chatId || !userMessage) {
      return res.status(400).json({ error: "chatId and message are required" });
    }
    const history = chatService.getChatHistory(chatId);

    const responseGPT = await openAIService.getChatGptResponse(
      history,
      userMessage
    );
    chatService.addMessageToChat(chatId, "user", userMessage);
    res.json({ response: responseGPT });
  } catch (error) {
    console.error("Error in the controller:", error);
    res.status(500).json({ error: error.message });
  }
}
// Method that calls only Deepseek
async function chatWithDeepseek(req, res) {
  try {
    console.log("Body received:", req.body);

    const { chatId, userMessage } = req.body;
    if (!chatId || !userMessage) {
      return res.status(400).json({ error: "Message is required" });
    }

    const responseDeepseek = await deepseekService.getDeepseekResponse(
      userMessage
    );
    res.json({ response: responseDeepseek });
  } catch (error) {
    console.error("Error in the controller:", error);
    res.status(500).json({ error: error.message });
  }
}

// Method to call both APIs (ChatGPT + Deepseek)

async function chatWithBoth(req, res) {
  try {
    console.log("Body received:", req.body);

    const { chatId, userMessage } = req.body;

    if (!chatId || !userMessage) {
      return res.status(400).json({ error: "chatId and message are required" });
    }

    // Obtains history from mongoDB
    const history = await chatService.getChatHistory(chatId);

    let responseTimes = { chatgpt: 0, deepseek: 0 };

    // Call both APIs in parallel
    const [responseGPT, responseDeepseek] = await Promise.allSettled([
      openAIService.getChatGptResponse(history, userMessage, responseTimes),
      deepseekService.getDeepseekResponse(history, userMessage, responseTimes),
    ]);

    // Concatenate responses
    //const combinedResponse = `Response GPT: ${responseGPT} Response Deepseek: ${responseDeepseek}`;
    const chatGPTResponse =
      responseGPT.status === "fulfilled"
        ? responseGPT.value
        : "Error in ChatGPT's answer";
    const deepSeekResponse =
      responseDeepseek.status === "fulfilled"
        ? responseDeepseek.value
        : "Error in Deepseek's answer";

    // Guarda mensajes en MongoDB
    await chatService.addMessageToChat(chatId, "user", userMessage);
    const _idGPTResponse = await chatService.addMessageToChat(
      chatId,
      "assistant",
      chatGPTResponse
    ); //deepseek and openai apis understand the "assistant" role as the answers generated by them. Then when loading
    const _idDeepseekResponse = await chatService.addMessageToChat(
      chatId,
      "assistant",
      deepSeekResponse
    ); //the history in the getOpenAIResponse/getDeepseekResponse they will know how to "continue" the conversation

    //use of responseService for obtaining the info encapsulated in a json
    const jsonResponse = responseService.generateChatMessageResponse(
      chatId,
      [
        {
          model: "chatgpt",
          id: _idGPTResponse,
          role: "assistant",
          message: chatGPTResponse,
        },
        {
          model: "deepseek",
          id: _idDeepseekResponse,
          role: "assistant",
          message: deepSeekResponse,
        },
      ],
      responseTimes
    );

    res.json(jsonResponse);
  } catch (error) {
    console.error("Error in the controller:", error);
    res.status(500).json({ error: error.message });
  }
}

module.exports = { chatWithBoth, chatWithOpenAIChatGPT, chatWithDeepseek };
